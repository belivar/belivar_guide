# 1.2 模块化 - Chapter 1 前端发展史

## 无模块时代
在ajax还未提出之前，js还只是一种“玩具语言”，用来在网页上进行表单校验、实现简单的动画效果等等，这个时候并没有前端工程师，服务端工程师只需在页面上随便写写js就能搞定需求。那个时候的前端代码大概像这样，代码简单的堆在一起，只要能从上往下依次执行就可以了。
```javascript
if(xx){
     //.......
}
else{
     //xxxxxxxxxxx
}
for(var i=0; i<10; i++){
     //........
}
element.onclick = function(){
     //.......
}
```

## 模块萌芽时代
2006年，ajax的概念被提出，前端拥有了主动向服务端发送请求并操作返回数据的能力，随着Google将此概念的发扬光大，传统的网页慢慢的向“富客户端”发展。前端的业务逻辑越来越多，代码也越来越多，于是一些问题就暴漏了出来：   
1. 全局变量的灾难
小明定义了 i=1   
小刚在后续的代码里：i=0   
小明在接下来的代码里：if(i==1){…} //悲剧   
2. 函数命名冲突
项目中通常会把一些通用的函数封装成一个文件，常见的名字有utils.js、common.js…   
小明定义了一个函数：function formatData(){   }   
小刚想实现类似功能，于是这么写：function formatData2(){   }   
小光又有一个类似功能，于是：function formatData3(){   }   
……   
避免命名冲突就只能这样靠丑陋的方式人肉进行。   
3. 依赖关系不好管理
b.js依赖a.js，标签的书写顺序必须是有序的，也不能漏写某个。在多人开发的时候很难协调。   
```html
<script type="text/javascript" src="a.js"></script>
<script type="text/javascript" src="b.js"></script>
```
在这个时代,人们提出了命名空间来解决:
```javascript
modA = function(){
     var a,b; //变量a、b外部不可见
     return {
          add : function(c){
               a + b + c;
          },
          format: function(){
               //......
          }
     }
}();

modB = function(){
     return {
          test : function(){
               return 'hello world';
          }
     }
}();
```
这样function内部的变量就全被隐藏了,达到封装的目的,但是命名空间依然是挂在全局变量上边,随着模块的增多依然会出现命名空间冲突问题,这时有人就提出了Java的package风格来定义命名空间:
```javascript
app.util.modA = xxx;
```
这样调用函数，写写都会觉得恶心，所以这种方式并没有被很多人采用。后来JQuery提出了匿名自执行函数:
```javascript
(function(window){
    //代码
    var JQuery = function () {  };
 
    window.jQuery = window.$ = jQuery;//通过给window添加属性而暴漏到全局
})(window);
```
通过匿名函数包装代码，所依赖的外部变量传给这个函数，在函数内部可以使用这些依赖，然后在函数的最后把模块自身暴漏给window。

### 模块化面临的问题
1. 如何安全的包装一个模块的代码？（不污染模块外的任何代码）
2. 如何唯一标识一个模块？
3. 如何优雅的把模块的API暴漏出去？（不能增加全局变量）
4. 如何方便的使用所依赖的模块？   

## CommonJS
2009年，nodejs横空出世，开创了一个新纪元，人们可以用js来编写服务端的代码了。如果说浏览器端的js即便没有模块化也可以忍的话，那服务端是万万不能的。
大牛云集的CommonJS社区发力，制定了Modules/1.0规范:
```
1. 模块的标识应遵循的规则（书写规范）
2. 定义全局函数require，通过传入模块标识来引入其他模块，执行的结果即为别的模块暴漏出来的API
3. 如果被require函数引入的模块中也包含依赖，那么依次加载这些依赖
4. 如果引入模块失败，那么require函数应该报一个异常
5. 模块通过变量exports来向往暴漏API，exports只能是一个对象，暴漏的API须作为此对象的属性。
```
此规范一出，立刻产生了良好的效果，由于其简单而直接，在nodejs中，这种模块化方案立刻被推广开了。
```javascript
// moduleA.js
exports.add = function() {
    var sum = 0, i = 0, args = arguments, l = args.length;
    while (i < l) {
        sum += args[i++];
    }
    return sum;
};

// moduleB.js
var moduleA = require('./moduleA');
moduleA.add();

// or
// moduleA.js
module.exports = function() {
    var sum = 0, i = 0, args = arguments, l = args.length;
    while (i < l) {
        sum += args[i++];
    }
    return sum;
};

// moduleB.js
var add = require('./moduleA');
add();
```

## AMD/RequireJs
AMD的思想正如其名，异步加载所需的模块，然后在回调函数中执行主逻辑。这正是我们在浏览器端开发所习惯了的方式。其规范如下:
```
1. 用全局函数define来定义模块，用法为：define(id?, dependencies?, factory);
2. id为模块标识，遵从CommonJS Module Identifiers规范
3. dependencies为依赖的模块数组，在factory中需传入形参与之一一对应
4. 如果dependencies的值中有”require”、”exports”或”module”，则与commonjs中的实现保持一致
5. 如果dependencies省略不写，则默认为[“require”, “exports”, “module”]，factory中也会默认传入require,exports,module
6. 如果factory为函数，模块对外暴漏API的方法有三种：return任意类型的数据、exports.xxx=xxx、module.exports=xxx
7. 如果factory为对象，则该对象即为模块的返回值
```
代码如下:
```javascript
//a.js 定义了A模块
define(function(){
     console.log('A模块加载');
     return {
          hello: function(){
               console.log('hello, a.js');
          }
     }
});

//b.js 定义了B模块并且依赖A模块
define(['a'], function(a){
     console.log('B模块加载');
     return {
          hello: function(){
               a.hello();
               console.log('hello, b.js');
          }
     }
});

//main.js
require(['b'], function(b){
     console.log('main.js执行');
     $('#b').click(function(){
          b.hello();
     });
});
```
上面的main.js被执行的时候，会有如下的输出：   
A模块加载   
B模块加载   
main.js执行   
在点击按钮后，会输出：hello, a.js \n hello, b.js   

这种方案大体来看是没什么问题,但是如果细细来看，a.js,b.js被预先加载并且预先执行了,即使用户没有点击按钮。这其实也是AMD/RequireJs被吐槽的一点，预先下载没什么争议，由于浏览器的环境特点，被依赖的模块肯定要预先下载的。问题在于，是否需要预先执行？另一点被吐槽的是，在定义模块的时候，要把所有依赖模块都罗列一遍，而且还要在factory中作为形参传进去，要写两遍很大一串模块名称，像这样：
```javascript
define(
    [
        'a', 
        'b', 
        'c', 
        'd', 
        'e', 
        'f', 
        'g'
    ], 
    function(a, b, c, d, e, f, g){  
        //..... 
    });
```
好的一点是，AMD保留了commonjs中的require、exprots、module这三个功能, 可以不把依赖罗列在dependencies数组中。而是在代码中用require来引入，如下：
```
// main.js
define(function(){
     console.log('main.js执行');
 
     require(['a'], function(a){
          a.hello();    
     });
 
     $('#b').click(function(){
          require(['b'], function(b){
               b.hello();
          });
     });
});
```
我们在define的参数中未写明依赖，那么main.js在执行的时候，就不会预先加载a.js和b.js，只是执行到require语句的时候才会去加载。这就是名副其实的“懒加载”了, 这种方式网页初始加载的速度会有明显提升,但是弊端也是显而易见的，在后续执行a.hello和b.hello时，必须得实时下载代码然后在回调中才能执行，这样的用户体验是不好的，用户的操作会有明显的延迟卡顿。但这样的现实并非是无法接受的，毕竟是浏览器环境，我们已经习惯了操作网页时伴随的各种loading。。。

## CMD/seajs
既然requirejs有上述种种不甚优雅的地方，所以必然会有新东西来完善它，这就是后起之秀seajs，seajs的作者是国内大牛淘宝前端步道者玉伯。
```javascript
//a.js
define(function(require, exports, module){
     console.log('A模块加载');
     return {
          hello: function(){
               console.log('hello, a.js');
          }
     }
});

//b.js
define(function(require, exports, module){
     console.log('B模块加载');
     return {
          hello: function(){
               console.log('hello, b.js');
          }
     }
});

//main.js
define(function(require, exports, module){
     console.log('main.js执行');
 
     var a = require('a');
     a.hello();    
 
     $('#b').click(function(){
          var b = require('b');
          b.hello();
     });
 
});
```
上面的main.js执行会输出如下：   
main.js执行   
A模块加载   
hello, a.js   
a.js和b.js都会预先下载，但是b.js中的代码却没有执行，因为还没有点击按钮。当点击按钮的时候，会输出如下：   
B模块加载执   
hello, b.js     
当然, 如果需要按需加载而不是预先加载可以使用 require.async:
```javascript
var b = require.async('b');
b.hello();
```
这样, B模块就不会预先被加载了,只有在执行的时候才会去加载B模块。

## ES6模块标准
模块化开发的呼声水涨船高，作为官方的ECMA必然要有所行动，js模块很早就列入草案, 终于在2015年6月份发布了ES6正式版。然而，可能由于所涉及的技术还未成熟，ES6移除了关于模块如何加载/执行的内容，只保留了定义、引入模块的语法。所以说现在的ES6 Module还只是个雏形，半成品都算不上。但是这并不妨碍我们先窥探一下ES6模块标准。
```javascript
//方式一, a.js
export var a = 1;
export var obj = {name: 'abc', age: 20};
export function run(){....}

//方式二, b.js
var a = 1;
var obj = {name: 'abc', age: 20};
function run(){....}
export {a, obj, run}

//main.js
import {run} from  'a';
run();

//main2.js
import foo from 'a'
console.log(foo.obj);
foo.run();
```

## AMD与CMD区别
最明显的区别就是在模块定义时对依赖的处理不同

1. AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块
2. CMD推崇就近依赖，只有在用到某个模块的时候再去require

这种区别各有优劣，只是语法上的差距，而且requireJS和SeaJS都支持对方的写法。   
同样都是异步加载模块，AMD在加载模块完成后就会执行改模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行

CMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的

这也是很多人说AMD用户体验好，因为没有延迟，依赖模块提前执行了，CMD性能好，因为只有用户需要的时候才执行的原因。

## 参考文章
[JavaScript 模块化历程](http://web.jobbole.com/83761/)   
[前端模块化](http://www.cnblogs.com/dolphinX/p/4381855.html)

## 操作
[返回目录](https://github.com/zfeng217/belivar_guide/blob/dev)   
[上一章](https://github.com/zfeng217/belivar_guide/blob/dev/content/1/1.1.md)   
[下一章](https://github.com/zfeng217/belivar_guide/blob/dev/content/1/1.3.md)   
